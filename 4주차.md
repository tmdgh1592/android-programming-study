# Chapter 8

## UI 유연성의 필요

UI 유연성

- 사용자나 장치가 요구하는 것 에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력

액티비티는 유연성을 제공하도록 설계되지 않았다.

액티비티의 뷰들은 런타임시에 변경, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야한다. → 사용하는 특정화면과 강하게 결합

## 프래그먼트 개요

프래그먼트

- 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체
    - 작업은 UI 관리를 말함.
- UI를 관리하는 프래그먼트 → UI 프래그먼트
    - 레이아웃 파일로부터 인플레이트 되는 자신의 뷰를 하나 갖는다.

액티비티는 여러개의 다른 프래그먼트 뷰를 수용하는 다수의 컨테이너를 가질 수 있다. 앱과 사용자가 원하는 화면을 구성 또는 변경하려면 액티비티와 연관된 하나 이상의 프래그먼트를 사용한다.

액티비티에서 기존의 프래그먼트를 다른 프래그먼트로 바꾸고 싶을 때 교체하면 되기 때문에 뷰가 변경되더라도 액티비티는 소멸하지 않는다.

## CriminalIntent 앱 개발 시작하기

> 액티비티는 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공 → `호스팅`
> 

프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없으며, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.

## CrimeFragment 클래스 생성하기

### 다른 타입의 프래그먼트들

새로 개발하는 안드로이드 앱은 `Jetpack 버전의 프래그먼트`를 사용해서 빌드해야 한다.

### 프래그먼트 생명주기 함수 구현하기

대부분의 프래그먼트 생명주기 함수는 이미 알고 있는 Activity 생명주기 함수와 대응된다. 

프래그먼트는 액티비티와 유사하게 자신의 상태 데이터를 저장하거나 가져오는 Bundle 객체를 갖는다.

프래그먼트의 뷰는 onCreateView 생명주기 함수에서 생성하고 구현한다. 

```kotlin
onCreateView(LayoutInflater, ViewGroup?. Bundle?)
// 프래그먼트 뷰의 레이아웃을 인플레이트한 후 인플레이트된 View를 호스팅 액티비티에 반환해야한다.
// LayoutInflater와 ViewGroup 매개변수는 레이아웃을 인플레이트하기 위해 필요하다.
// Bundle은 저장된 상태 데이터를 가지며, onCreateView 함수에서 뷰를 재생성하는데 사용된다.
// 함수 내부에서 레이아웃 리소스 ID를 인자로 전달해 LayoutInflater.inflate()를 호출함으로써 프래그먼트의 뷰를 명시적으로 인프레이트 한다.
// inflate() 함수의 두 번째 인자는 위젯들을 올바르게 구성하는 데 필요한 뷰의 부모
// 세 번째 인자는 인플레이트된 뷰를 이 뷰의 부모에게 즉시 추가할 것인지를 LayoutInflater에 알려준다.
// -> 여기서는 false로 전달, 이 프래그먼트의 뷰는 액티비티의 컨테이너 뷰에 호스팅되기 때문
```

### 프래그먼트에 위젯 연결하기

View.findViewById(int)를 호출해 프래그먼트에 위젯을 연결할 수 있다.

TextWatcher 리스너는 onStart()에서 설정해야함

→ 사용자와 뷰가 상호 작용할 때뿐만 아니라 장치 회전 등으로 인해 뷰 상태가 복원되면서 데이터가 설정될 때도 작동되는 리스너가 있기 때문 ex) TextWatcher, OnCheckChangedListener(CheckBox)

→ 뷰의 상태는 onCreateView()가 호출된 이후와 onStart()가 호출되기 전에 복원

→ onStart()에서 설정하지 않으면 리스너의 함수 세개가 뷰 상태 복원 전에 실행되어, 복원되지 못한 데이터가 설정되는 문제가 생긴다. 

→ OnClickListener 같이 사용자와 상호작용할 때만 반응하는 리스너는 onCreate()에서 해주면 됨

## FragmentManager에 UI 프래그먼트 추가하기

**FragmentManager**

- 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택을 처리한다.
- 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 갖는다.

### 프래그먼트 트랜잭션

```kotlin
if(currentFragment == null) {
	val fragment = CrimeFragment()
	supportFragmentManager
		.beginTransaction()
		.add(R.id.fragment_container, fragment_
		.commit()

// 프래그먼트 트랜잭션을 생성하고 커밋한다.
// 새로운 프래그먼트 트랜잭션 인스턴스를 생성하고 이 인스턴스에 add() 오퍼레이션을 포함시킨 후 커밋해랴는 의미
```

**프래그먼트 트랜잭션**

- 프래그먼트 리스트에 프래그먼트를 추가, 삭제, 첨부, 분리, 변경하는데 사용된다.
- 여러 개의 오퍼레이션(트랜잭션으로 실행되는 각 함수 코드)을 묶어서 수행할 수 있다.
- 프래그먼트 트랜잭션의 백 스택을 유지 관리한다.
    - 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 트랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다.

```kotlin
FragmentManager.beginTransaction()
// FragmentTransaction의 인스턴스를 생성해 반환한다.
// FragmentTransaction 클래스는 플루언트 인터페이스 사용
	 -> 플루언트 인터페이스는 코드를 이해하기 쉽게 해주는 객체지향 기법, 함수의 연쇄 호출 형태로 구현
// FragmentTransaction 함수는 FragmentTransaction 객체를 반환하기 때문에 이 함수들을 연쇄 호출
```

- 코틀린 Unit → 하나의 인스턴스만 생성되는 싱글톤 객체, 자바의 void와 같이 함수의 반환 값이 없음을 나타내는데 사용

```kotlin
add()

// 이 함수는 컨테이너 뷰 ID와 새로 생성된 프래그먼트 인스턴스를 매개변수로 갖는다.
```

**컨테이너 뷰 ID**

- 액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 FragmentManager에 알려준다.
- FragmentManager의 리스트에서 프래그먼트를 고유하게 식별하는데 사용된다.

### FragmentManager와 프래그먼트 생명주기

프래그먼트 생명주기는 액티비티 생명주기와 유사하다. 액티비티와 프래그먼트의 생명주기 함수가 대응된다. 프래그먼트는 액티비티를 대신해 작동하므로 프래그먼트의 상태는 액티비티의 상태를 반영해야 한다.

프래그먼트 생명주기 함수는 호스팅 액티비티의 FragmentManager가 호출된다.

안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서는 아무것도 모른다.

`onAttach(Context?)` , `onCreate(Bundle?)` , `onCreateView(...)` , `onViewCreated(...)` 함수들은 프래그먼트를 FragmentManager에 추가할 때 호출된다.

`onActivityCreated(Bundle?)` 함수는 호스팅 액티비티의 onCreate 함수가 실행된 후 호출된다. 프래그먼트가 추가된 후 호출된다

이미 실행 중 일 때 프래그먼트를 추가하면 FragmentManager는 해당 프래그먼트가 호스팅 액티비티의 상태를 따라잡는데 필요한 프래그먼트 생명주기 함수를 몇 개이든 차례대로 즉시 호출

## 프래그먼트를 사용하는 애플리케이션 아키텍처

프래그먼트는 주요 컴포넌트들을 재사용하게끔 캡슐화 한다.

- 주요 컴포넌트는 앱의 전체화면에 나타난다.

작은 컴포넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰로 추출하는 것이 좋은 방법이다.

일반적으로 한 화면에는 최대 두 개 또는 세 개 정도의 프래그먼트를 사용하는 것이 좋다.

# Chapter 9

## 새로운 프래그먼트 및 ViewModel 추가하기

```kotlin
private val crimeListViewModel: CrimeListViewModel by lazy {
	ViewModelProvider(this).get(CrimeListViewModel::class.java
}
//ViewModelProvider(this)를 호출하면 현재의 CrimeListFragment 인스턴스와 연관된 ViewModelProvider 인스턴스를 생성하고 반환한다.
//get()에서는 CrimeListViewModel 인스턴스 반환
```

```kotlin
companion object {
	fun newInstance(): CrimeListFragment {
			return CrimeListFragment()
	} // CrimeListFragment 클래스의 인스턴스를 생성하고 반환한다.
}
```

### 프래그먼트에 사용되는 ViewModel 추가하기

ViewModel이 프래그먼트와 같이 사용되면 액티비티 대신 프래그먼트의 생명주기와 결합된다.

프래그먼트의 뷰가 화면에 나타나 있는 한 ViewModel은 활성화된 상태를 유지하며, 장치 회전시에도 유지되어 새로 생성된 프래그먼트 인스턴스가 이어서 사용할 수 있다.

ViewModel은 프래그먼트가 소멸될 때 같이 소멸된다.

프래그먼트 트랜잭션을 백 스택에 추가할 때

→ 현재 프래그먼트를 다른 것으로 교체할 때 트랜잭션이 백 스택에 추가된다면 해당 프래그먼트 인스턴스와 이것의 ViewModel은 소멸되지 않는다.

## RecyclerView 추가하기

RecyclerView가 생성된 후에는 곧바로 `LayoutManager` 를 설정해야하며, 설정하지 않으면 작동하지 않음

- RecyclerView는 항목들을 화면에 위치시키는 일을 직접하지 않고 LayoutManager에 위임

## 항목 뷰 레이아웃 생성하기

RecyclerView

- ViewGroup의 서브 클래스
- `항목 뷰(item view)` 라고 하는 자식 View 객체들의 리스트 보여준다.
- 각 항목은 자신의 뷰 계층 구조를 가질 수 있다.

## ViewHolder 구현하기

RecyclerView는 항목 View가 ViewHolder 인스턴스에 포함되어 있다고 간주

- ViewHolder는 항목 View의 참조를 갖는다.

RecyclerView는 자체적으로 View를 생성하지 않으며, 항상 항목 View를 참조한는 ViewHolder를 생성한다.

## 어댑터를 구현해 RecyclerView에 데이터 채우기

RecyclerView는 자신이 ViewHolder를 생성하지 않고 이 일을 `어댑터(adapter)` 에 요청

- 어댑터는 컨트롤러 객체, 리사이클러뷰와 리사이클러뷰가 보여줄 데이터 사이에 위치

어댑터가 하는 일

- 필요한 ViewHolder 인스턴스 생성
- 모델 계층의 데이터를 ViewHolder들과 바인딩

리사이클러뷰가 하는 일

- 새로운 ViewHolder 인스턴스의 생성을 어댑터에게 요청
- 지정된 위치의 데이터 항목에 ViewHolder를 바인딩하도록 어댑터에게 요청

```kotlin
onCreateViewHolder(parent: ViewGroup, viewType: Int)
// 보여줄 뷰를 인플레이트한 후 이 뷰를 처리하는 ViewHolder 인스턴스를 생성하고 반환
// viewType -> 같은 리사이클러뷰에 서로 다른 타입의 뷰를 보여줄 때만 필요
```

```kotlin
onBindViewHolder(holder: CrimeHolder, position: Int)
// ViewHolder에 바인딩하는 역할
```

```kotlin
getItemCount()
// 데이터가 저장된 데이터 셋에 몇 개의 데이터가 있는지 알 수 있다. 
```

## RecyclerView의 어댑터 설정하기

```kotlin
crimeRecyclerView.adapter = adapter
//adpater는 리사이클러뷰의 속성
```

코틀린에서 속성의 값을 보전하는 필드를 내부적으로 유지 → `후원 필드`

- 속성의 값을 참조할 때는 게터가 자동 호출되며, 속성의 값을 지정/변경 할때는 세터가 자동 호출된다.

## 뷰의 재활용: RecyclerView

리사이클러뷰는 한 화면을 채우는 데 충분한 개수만 생성해, 화면이 스크롤되면서 항목 View가 화면을 벗어날 때 리사이클러뷰는 해당 항목 View를 버리지 않고 재활용한다.

→ onCreateViewHolder 함수는 onBindViewHolder 함수보다 덜 호출된다.

→ 일단 충분한 수의 ViewHolder가 생성되면 onCreateViewHolder의 호출을 중단하고 기존의 ViewHolder를 재활용해 onBindViewHolder에 전달함으로써 시간과 메모리 절약

## 리스트 항목의 바인딩 개선하기

데이터 바인딩 작업을 수행하는 모든 코드는 ViewHolder 내부에 두는 것이 좋다. 

→ ViewHolder와 Adapter 간의 기능 분담을 하기 위해서
