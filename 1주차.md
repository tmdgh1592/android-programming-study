# Chapter2 

### 새로운 클래스 만들기 
질문 텍스트와 정답을 가지고 있는 Question 클래스를 만들어보면 다음과 같이 만들 수 있다.

``` Kotlin
data class Question(@StringRes val textResId: Int, val answer: Boolean)
```

여기서 @StringRes 애노테이션을 왜 사용할까?
1. 생성자에서 유효한 문자열 리소스 ID를 제공하는지를 컴파일 시점에서 Lint가 검사한다. -> 유효하지 않은 리소스 ID가 생성자에 사용되어 런타임 시에 앱이 중단되는 것을 방지
2. 다른 개발자가 쉽게 코드를 알 수 잇다.


그리고 또 여기서 의문점!
왜 질문 텍스트를 Int 타입으로 했을까? A) 문자열 리소스의 ID를 가져오도록 하였기 때문이다. Arrays에 질문리스트들을 저장해놓고 거기서 문자열 ID를 통해 질문 텍스트를 가져오도록 한 것 같다.

위와 같이 Question 클래스처럼 비즈니스 로직을 처리하는 함수 보다는 주로 데이터를 저장하는 속성을 갖는 경우가 있는데 이런 클래스의 경우, euqals(), hashCode(), toString()이 필요하다.
이런 이유로 코틀린에서는 data class라는 개념을 추가하였고 위와 같이 필요한 함수들을 자동으로 생성해준다.


### 모델-뷰-컨트롤러와 안드로이드
MVC의 주요 관점은 애플리케이션의 어떤 객체든 모델 객체 or 뷰 객체 or 컨트롤러 객체가 되어야한다는 것이다.

- 모델 객체 <br/>
  `데이터`와 `비즈니스 로직`을 가짐. UI를 모르며 데이터를 보존하고 관리하는 것이 유일한 목적
- 뷰 객체 <br/>
  화면에 볼 수 있는 것
- 컨트롤러 객체 <br/>
  뷰와 모델 객체 결속, `애플리케이션 로직` 포함, 뷰 객체에 의한 이벤트에 응답, 모델 객체 및 뷰 계층과 주고받는 데이터 흐름 관리


### MVC 사용하기
애플리케이션 기능 많아짐 -> 복잡, 이해의 어려움 -> 클래스로 분리(설계 도움, 이해 쉬워짐)
클래스를 모델, 뷰, 컨트롤러 계층으로 분리하면 애플리케이션 설계, 이해 도움됨.
MVC는 클래스 재사용하기 쉽도록 해줌, 제한된 책임을 갖는 클래스를 재사용하는 것이 더 쉬움 
> 위의 Question 클래스를 보자. Question 클래스는 질문 텍스를 보여주는 뷰를 모르기 때문에 Question 클래스를 다른 목적으로 사용하기 쉬워진다.

MVC를 사용하면 크고 복잡한 앱에서는 컨트롤러 계층이 훨씬 커지거나 복잡해질 수 있다. 보통 액티비티나 다른 컨트롤러를 가볍게 유지하려고 한다.

그렇기 때문에 앱의 컨트롤러를 가볍게 만드는 데 MVC는 적합하지 않다.

### 아이콘 추가하기

> 장치의 화면 픽셀 밀도를 나타내는 수식자
> - mqdi: 중밀도 화면(~160dpi)
> - hpdi: 고밀도 화면(~240dpi)
> - xhdpi: 초고밀도 화면(~320dpi)
> - xxhdpi: 극초고밀도 화면(~480dpi)
> - xxxhdpi: 궁극초고밀도 화면(~480dpi)

어떤 화면 밀도 수직자에도 포함되지 않는 화면 밀도를 갖는 장치에서 앱을 실행하면 안드로이드 운영체제가 해당 장치에 적합한 크기로 이미지 조정 
-> 모든 종류의 화면 밀도로 된 이미지 제공하지 않아도 됨

### 화면 픽셀 밀도

> 텍스트 크기: 화면에 나타나는 텍스트의 픽셀 높이 <br/>
> 마진: 뷰 바깥의 여백 <br/>
> 패딩: 뷰 내부의 여백 <br/>

<br/>

> - px(pixel): 픽셀, 1픽셀 = 화면의 1픽셀, 화면 밀도에 적합하게 조정되지 않아서 권장하지 않음
> - dp(density-independent pixel): 밀도 독립적 픽셀, 1dp = 화면의 1/160인치, 화면 밀도와 무관하게 일정한 크기를 가짐
> - sp(scale-independent pixel): 크기 독립적 픽셀, 사용자의 폰트 크기 선택 고려한 dp, 화면에 나타나는 텍스트 크기 설정 위해 사용
> - pt,mm,in: 포인트, 밀리미터, 인치, 모든 장치에 잘 맞도록 구성되지 않아 사용 권장하지 않음
> 안드로이드는 런타임시에 이 값들을 픽셀로 변환


# Chapter 3

### 액티비티 상태와 생명주기 콜백
액티비티는 4가지 상태로 상호 전환된다.

- 존재하지 않음: 소멸 상태(액티비티가 런칭 되지 않았거나 소멸), 액티비티 인스턴스 메모리에 존재하지 않음, 뷰도 없음
- 중단: 액티비티가 인스턴스에 존재하지만 뷰는 볼 수 없음, 액티비티 처음 시작시에 거쳐가는 상태, 액티비티 인스턴스 뷰가 화면에서 가려졌을 때 언제든 다시 진입하는 상태
- 일시 중지: 액티비티 포그라운드에서 작동하지는 않지만, 액티비티 인스턴스 뷰 전체 또는 일부를 화면에서 볼 수 있음
- 실행 재개: 액티비티 메모리에 있고 화면 볼 수 있고 포그라운드에 있음. 현재 상호 작용하고 있는 액티비티의 상태를 말함. 장치의 전체 시스템에 걸쳐 하나의 액티비티만 이 상태를 가질 수 있음.

#### 생명주기 콜백
> onCreate(), onStart(), onResume(), onPause(), onStop(), onDestroy() 

위 함수들의 경우 우리가 호출하지 않아도 됨, 액티비티 생명주기 콜백 함수들을 오버라이드 하면 됨

### 액티비티 생명주기 로깅하기

최상위 수준 속성을 사용하는 상황
1. 특정 클래스의 인스턴스를 생성하지 않고 바로 사용가능하기 때문에 애플리케이션이 실행되는 동안 속성값 계속 보존 해야할 상황
2. 애플리케이션 전체에서 사용하는 상수를 정의할 때

**슈퍼 클래스를 오버라이드 하는 콜백함수는 오버라이드 되는 슈퍼 클래스 함수를 호출하는 코드가 맨 앞에 있어야 한다**

생명주기 콜백 함수에서 override가 키워드가 있는 이유 <br/>
-> 오버라이드하는 함수가 슈퍼 클래스에 있는지 컴파일러에게 확인하라고 요청하기 위해서 <br/>
-> override 키워드를 사용하면 오타로 인한 에러 발생을 런타임이 아닌 컴파일 시점에 방지 

### 액티비티 생명주기가 사용자 액션에 어떻게 응답하는지 살펴보기 

앱이 설치 및 실행될 때 `onCreate(Bundle?)`, `onStart()`, `onResume()` 호출되고 MainActivity 인스턴스 생성, `실행 재개 상태(메모리에 로드되고, 사용자에게 보이며, 포그라운드에서 작동)`

#### 일시적으로 액티비티 떠나기

홈 버튼을 누르면 `onPause()`, `onStop()` 호출<br/>

오버뷰 화면(최근 앱 화면, 태스크 매니저)에서 태스크를 클릭하면 `onStart()`, `onResume()` 호출<br/>
-> 여기서 onCreate()이 호출되지 않은 이유는 MainActivity 인스턴스가 여전히 메모리에 있기 때문에 다시 생성될 필요가 없기 때문이다.

다중 창 모드(multi window mode)<br/>
-> 누가 이상에서만 사용 <br/>
-> 다중 창 모드에서 아래 창에 열린 다른 앱을 클릭하면 MainActivity는 `onPause()` 호출
-> 다중 창 모드에서 위에 창에 열린 MainActivity를 클릭하면 `onResume()` 호출

#### 액티비티 끝내기

백 버튼을 누르면 `onPause()`, `onStop()`, `onDestroy()` 호출, MainActiviy 인스턴스가 존재하지 않는 상태(메모리에 없고, 화면에도 보이지 않으며, 포그라운드에서 동작하지 않음)

오버 뷰 화면에서 앱의 카드를 옆으로 밀어내 앱을 끝낼 수 있고 finish() 함수를 호출해 액티비티를 끝낼 수 있다.

#### 액티비티 회전시키기

액티비티 방향 회전시 MainActivity 인스턴스 소멸되었다가 새로운 인스턴스 생성 

### 장치 구성 변경과 액티비티 생명주기

장치 회전시에 `장치 구성`이 변경됨
> 장치 구성이란? 각 장치의 현재 상태를 나타내는 특성들의 집합으로 장치 구성을 이루는 특성에는 화면 방향, 화면 밀도, 화면 크기, 키보드 타입, 도크 모드, 언어 등이 있다.

런타임 구성변경이 생길 때 -> 현재의 액티비티 인스턴스 소멸, 새로운 구성에 가장 적합한 리소스 찾음, 찾은 리소스를 사용해서 해당 액티비티의 새 인스턴스 다시 빌드


### 궁금중 해소하기: UI 변경과 다중 창 모드
다중 창 모드에서 화면 위 창에는 MainActivity가 있고 아래 창에는 비디오를 재생하는 앱이 있다고 하자. 많은 개발자들은 UI와 관련해서 진행 중인 변경의 시작과 중단을 `onResume()`과 `onPause()`에서 하는 것이 일반적이었다. 하지만 다중 창 모드 인경우에는 위 창을 클릭한 경우에는 비디오를 재생하는 앱이 있는 아래 창은 `onPause()` 상태가 된다. 그렇게 되면 비디오를 볼 수 없는 상황이 생긴다.
따라서 이러한 문제를 해결하기 위해 `onStart()`에서 비디오를 재생하고 `onStop()`에서 비디오를 중단하도록 코드를 변경해줘야한다.

> 안드로이드 9이상 부터는 앱이 실행될 때 manifest 파일에<br/>
> ```<meta-data android:name="android.allow_multiple_resumed_activities" android:value="true">``` 를 추가하면 `다중 실행 재개 모드 사용할 수 있다.

   














