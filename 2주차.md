# Chapter 4

### ViewModel 추가하기

**ViewModel**
- 특정 액티비티 화면과 연동되며, 화면에 보여 줄 데이터를 형식화하는 로직을 두기 좋은 곳
- 모델 객체와 연동되어 모델을 `장식한다`
- 모델 데이터를 화면에 보여주는 기능을 수행
- 화면에서 필요한 모든 데이터를 한곳에서 종합하고 데이터를 형식화할 수 있음

**android.lifecycle 패키지**
> 생명주기를 인식하는 컴포넌트를 비롯해서 생명주기 관련 API 제공<br/>
> ViewModel도 이 일부

생명주기 컴포넌트 -> 액티비티와 같은 다른 컴포넌트의 생명주기를 관찰, 상태 고려해 작동

```Kotlin
val provider = ViewModelProvider(this) // 현재 액티비티와 연관된 ViewModelProvider 인스턴스를 생성하고 반환
val quizViewModel = provider.get(QuizViewModel::class.java) // QuizViewModel 인스턴스 반환
```
`ViewModelProvider는 ViewModel의 레지스트리처럼 작동한다.`<br/>
-> 액티비티 인스턴스가 처음으로 QuizViewModel을 요청하면 ViewModelProvider가 새로운 QuizViewModel 인스턴스 생성하고 반환 <br/>
-> 장치 구성이 변경되어 새로 생성된 MainActivity 인스턴스가 QuizViewModel을 또 요청하면 QuizViewModel 인스턴스가 새로 생성되지 않고 최초 생성되었던 인스턴스 반환<br/>
-> MainActivity 인스턴스가 종료되어 소멸될 때는 QuizViewModel 인스턴스도 같이 메모리에서 제거됨

### ViewModel 생명주기와 ViewModelProvider

**ViewModel 인스턴스는 액티비티 생명주기와 연동**
- ViewModel 인스턴스는 액티비티 상태 변화와 무관하게 액티비티가 종료될 때까지 메모리에 남아 있다가 액티비티가 종료되면 소멸된다.
- 장치의 회전 등에 따른 구성변겨이 생길 때마다 현재의 액티비티 인스턴스는 소멸되고 다시 새 인스턴스가 생성되지만, 액티비티와 연관된 ViewModel은 메모리에 남는다.

> MainActivity와 QuizViewModel은 `단방향`<br/>
> 액티비티는 ViewModel을 참조하지만, ViewModel은 액티비티를 참조하지 않는다.<br/>
> **ViewModel은 액티비티나 다른 뷰의 참조를 가지면 안된다. 메모리 leak이 발생할 수 있다.**

장치 회전시에 액티비티 인스턴스는 소멸되지만, ViewModel 인스턴스는 메모리에 남는다.<br/>
ViewModel 인스턴스가 액티비티 인스턴스에 대해 강한 참조를 가지면 두가지 문제가 생긴다.
1. 액티비티 인스턴스가 메모리에서 제거되지 않아서 인스턴스가 사용하는 메모리가 유실
2. ViewModel 인스턴스가 현재 사용되지 않는 과거 액티비티의 참조를 갖게 되어 ViewModel 인스턴스가 과거 액티비티의 뷰를 변경하려고 하면 IllegalStateException이 발생

### ViewModel에 데이터 추가하기

#### 액티비티를 간단하게 유지하면 좋은 이유
- 액티비티에 추가되는 모든 코드를 뜻하지 않게 액티비티 생명주기의 영향을 받을 수 있기 때문
- 액티비티는 화면에 나타나는 것을 처리하는 것만 집중하고, 보여줄 데이터를 결정하는 내부 로직은 신경쓰지 않아도 된다.

```kotlin
//by lazy 키워드를 사용하면 val로 선언
//액티비티 인스턴스가 생성될 때 QuizViewModel 인스턴스 참조를 quizViewModel에 한번만 저장함
//최초로 quizViewModel이 사용될 때까지 초기화를 늦출 수 있음
//
private val quizViewModel: QuizViewModel by lazy {
  ViewModelProvider(this).get(QuizViewModel::class.java)
}
```

### 프로세스 종료 시에 데이터 보존하기

> 각 앱은 **프로세스**로 실행<br/>
> 프로세스는 UI 관련 작업을 실행하는 하나의 스레드와 앱의 객체들을 저장하는 메모리 포함

 사용자가 다른 앱으로 이동하거나 안드로이드 운영체제가 메모리를 회수할 때 앱의 프로세스는 안드로이드 운영체제에 의해 소멸된다.<br/>
 앱의 프로세스가 소멸될 때는 이 프로세스에 저장된 모든 객체들도 같이 소멸된다.

 안드로이드 운영체제가 앱의 프로세스를 소멸시킬 때는 메모리에 있는 앱의 모든 액티비티들과 ViewModel들이 제거되지만, 액티비티나 ViewModel의 그 어떤 생명주기 콜백함수 호출되지 않음

 **Saved Instance State**
 - 안드로이드 운영체제가 일시적으로 액티비티 외부에 저장하는 데이터

 onSavedInstanceState(Bundle)에서는 현재 액티비티의 모든 뷰가 자신들의 상태를 Bundle 객체의 데이터로 저장<br/>

 ### onSavedInstanceState(Bundle) 오버라이드 하기

 onCreate(Bundel?)에서는 null이 될 수 있는 Bundle 객체 참조를 인자로 받는다. 액티비티의 새로운 인스턴스가 최초로 생성될 때는 상태 데이터가 없어서 Bundle 객체 참조가 null이 되기 때문
 하지만, 장치 회전이나 프로세스 종료 후 액티비티 인스턴스가 다시 생성될 때는 Bundle 객체 참조가 null이 아니다. 

 ### SIS와 액티비티 레코드

 > onSavedInstanceState(Bundle)이 호출될 때 데이터가 저장된 Bundle 객체는 안드로이드 운영체제에 의해 액티비티의 **액티비티 레코드**에 저장

액티비티가 보존 상태이면 액티비티 인스턴스는 존재하지 않지만, 액티비티 레코드 객체는 안드로이드 운영체제에 살아있다. 따라서 안드로이드 운영체제는 해당 액티비티 레코드를 사용해서 액티비티를 되살릴 수 있다.

액티비티는 onDestroy()가 호출되지 않고 보존상태가 될 수 있다. 장치에 이상이 생기지 않는 한, onStop()과 onSaveInstanceState(Bundle)이 호출되는 것에 의존해서
코드를 작성하면 된다. 

액티비티가 종료되면 액티비티 레코드도 같이 소멸된다. 액티비티 레코드는 장치가 다시 부팅될 때도 폐기된다.

### ViewModel vs SIS

**SIS**
- 프로세스가 종료될 때는 물론이고, 장치의 구성 변경이 생길 때에도 Bundle 객체를 사용해서 액티비티 레코드를 저장할 수 있다.

**ViewModel**
- 액티비티의 동적 데이터를 처리할 때 사용하기 좋다.

프로세스가 종료되면 ViewModel이 처리하지 못함, 자신이 가진 모든 것이 프로세스와 함께 메모리에서 완전히 제거되기 때문이다.<br/>
SIS는 직렬화되어 디스크에 저장되므로 크거나 복잡한 객체를 저장하는 것은 피해야 한다.

> UI 상태를 다시 생성하기 위해 필요한 소량의 정보를 저장할 때는 SIS 사용하고, 장치 구성변경이 생겨서 UI 넣는데 필요한 많은 데이터에 빠르고 쉽게 접근하고자
> 메모리를 캐싱할 때는 ViewModel 사용한다.


# Chapter 5

### 예외와 스택 기록

`fatal exception`을 log에 입력하면 앱을 중단시킨 예외 메시지를 찾아 보여준다.
- 최상위 수준의 예외와 이것의 스택 기록, 예외를 초래한 예외들과 이 예외들의 스택 기록을 이어서 보여준다.

### 중단점 설정하기

`중단점`은 설정된 해당 라인이 실행되기 전에 실행을 일시 중지시켜서 그 다음부터 어떻게 실행되는지 코드를 한 줄씩 살펴볼 수 있게 해준다.

`안드로이드 프로세스에 디버거 연결`은 실행중인 앱을 다시 시작하지 않고 디버깅할 수 있다.

**스택 기록 로깅**
- 코드의 여러 곳에서 발생한 스택 기록을 하나의 로그에서 볼 수있다.
- 무슨 일이 생겼는지 알려면 로깅 코드를 추가하고, 앱을 다시 빌드, 배포, 조사하는 방법을 새로 배워야한다.

**디버거**
- 앱이 실행되는 동안 중단점을 설정해 이것저것 살펴보면서 여러가지 문제에 관한 정보를 얻을 수 있다.

### 안드로이드 특유의 디버깅

**안드로이드 Lint**
- 안드로이드 코드의 정적 분석기(앱을 실행하지 않고 코드를 검사해 결함을 찾는 프로그램)
- 안드로이드 프레임워크에 관한 자신의 지식을 사용해 사전에 코드를 더 깊이 있게 살펴보고, 컴파일러가 알 수 없는 문제를 찾는다.


