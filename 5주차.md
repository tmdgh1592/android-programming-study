# 10장

레이아웃 중첩은 레이아웃을 파악하고 변경하는데 어렵게 하며, 앱의 성능도 저하된다.

→ 중첩된 레이아웃은 안드로이드 운영체제가 처리하고 보여주는데 시간이 오래 걸리기 때문이다.

> ConstraintLayout을 사용하면 중첩하지 않고도 복잡한 레이아웃을 만들 수 있다.
>

## ConstraintLayout 개요

ConstraintLayout을 사용할 때는 `제약` 들을 레이아웃에 추가한다.

- 여기서 제약은 두개의 물건을 연결해 끌어당기는 고무 밴드라고 생각하면 된다.
- ConstraintLayout에 뷰(위젯)을 위치시킬때는 제약만 지정하면 된다.

위젯의 크기 조정 방법

1. 위젯이 포함한 콘텐츠에 맞춰 스스로 결정(wrap_content)
2. 직접 지정
3. 지정된 제약에 맞춰 위젯이 자동으로 확장되게 하는 방법(match_constraint, 0dp)

## 레이아웃 편집기 개요

기준선이나 분리선 모두 디자인 시점에서만 사용되고 런타임 시에는 나타나지 않는다.


## 공간 확보하기

**뷰 크기 설정 유형**

- 고정 크기(Xdp) - 변경되지 않는 크기로 뷰를 지정한다. 크기 지정 단위는 dp
- 내용에 맞춤(wrap_content) - 뷰에서 `원하는` 크기가 자동 지정된다.
- 제약에 맞춤(0dp) - 지정된 제약에 맞춰 뷰의 크기가 신축성 있게 조정된다.

## ConstraintLayout의 내부 작업

모든 위젯은 단일 ConstraintLayout의 직계 자식이며 중첩된 레이아웃이 없다. 만일 LinearLayout을 사용해서 이와 똑같은 레이아웃을 생성했다면 하나의 LinearLayout 내부에 또 다른 LinearLayout이 중첩되었을 것이다.

레이아웃 중첩을 줄이면 레이아웃을 처리하고 보여주는 시간도 단축되어서 더 빠르고 매끄러운 사용자 경험을 제공할 수 있다.

## 스타일, 테마, 테마 속성

- 스타일(style)
    - 위젯이 어떻게 보이고 작동하는지를 나타내는 속성들을 갖는 xml 리소스
- 테마(theme)
    - 스타일의 모음
    - 자신의 속성이 다른 스타일 리소스들을 가리키는 스타일 리소스
- 테마 속성 참조
    - 앱의 테마 스타일을 위젯에 적용할 수 있다.

## 궁금증 해소하기: 마진 vs 패딩

마진(margin)

- 레이아웃 매개변수이며 위젯들 간의 간격
- 위젯 자신은 마진을 알 수 없고, 해당 위젯의 부모가 마진을 처리해야 한다.

패딩(padding)

- 레이아웃 매개변수가 아니다.
- 위젯이 갖고 있는 콘텐츠보다 자신이 얼마나 더 커야 하는지를 나타낸다.
- android:padding

 

## 궁금증 해소하기: ConstraintLayout의 다른 기능

가이드라인

- 앱 화면에 나타나지 않으며 뷰를 배치하는데 도움을 주는 도구
- 수평과 수직 방향
- dp 갑을 사용하거나 화면에 대한 비율(%)로 설정해 특정 위치에 둘 수 있다.

# 11장

viewModel과 SIS는 UI와 관련된 적은 수의 데이터에는 아주 좋다. 하지만 이 방법은 UI와 결부되지 않는 데이터의 저장에는 사용할 수 없다. 또한 액티비티나 프래그먼트 인스턴스에 연관되지 않으면서 UI 상태와 무관하게 영구적으로 지속할 필요가 있는 데이터 저장에도 사용할 수 없다.

## Room 아키텍처 컴포넌트 라이브러리

**Room**

- Jetpack의 아키텍처 컴포넌트 라이브러리
- 데이터베이스 설정과 사용을 쉽게 해준다.
- 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.
- API, 애노테이션, 컴파일러로 구성되어 있다.
    - API - 데이터베이스를 정의하고 인스턴스를 생성하기 위해 상속받는 클래스들이 포함
    - 애노테이션 - 데이터베이스에 저장할 필요가 있는 클래스, 데이터베이스를 나타내는 클래스, 데이터베이스 테이블을 사용하는 함수들을 정의하는 클래스 등을 나타내기 위해 사용
    - 컴파일러 - 지정한 애노테이션을 컴파일해서 데이터베이스 구현체를 생성

kotlin-kapt

- 코틀린 애노테이션 처리 도구
- 라이브러리가 생성한 클래스들을 안드로이드 스튜디오에서 알 수 있으므로 import해서 사용할 수 있다.

room-runtime

- 데이터 베이스를 정의하는데 필요한 모든 클래스와 어노테이션을 포함하는 Room API

room-compiler

- 지정한 애노테이션을 컴파일해서 데이터베이스 구현체를 생성한다.
- kapt 키워드를 사용해 Room 컴파일러가 생성한 클래스들을 안드로이드 스튜디오가 알 수 있게 한다.

## 데이터베이스 생성하기

Room으로 데이터베이스 생성 시 단계

1. 모델 클래스에 애노테이션을 지정해 데이터베이스 entity로 만든다.
2. 데이터베이스 자체를 나타내는 클래스를 생성한다.
3. 데이터베이스가 모델 데이터를 처리할 수 있게 타입 변환기를 생성한다.

### 엔터티 정의하기

Room은 우리가 정의한 엔티티를 기반으로 앱의 데이터베이스 테이블 구조를 만든다.

- 엔티티 → 우리가 생성하는 모델 클래스, @Entity 애노테이션으로 지정, 애노테이션으로 Room이 해당 클래스의 데이터베이스 테이블을 생성한다.

```kotlin
@Entity // 클래스 수준에 적용된다.
data class Crime(@PrimaryKey val id: UUID = UUID.randomUUID(),
								 var title: String = "",
								 var date: Date = Date(),
								 var isSolved: Boolean = false)

// @PrimaryKey(기본키)
// 테이블의 모든 행에 고유한 데이터를 갖는 열이므로 각 행을 검색하는데 사용할 수 있다.
```

### 데이터베이스 클래스 생성하기

엔티티 클래스는 데이터베이스 테이블의 구조를 정의한다. 앱에 여러 개의 데이터베이스가 있을 때는 특정 엔티티 클래스는 여러 데이터베이스에서 사용될 수 있다. 이런 이유로 엔티티 클래스를  데이터베이스와 연관시켜 주어야 Room이 테이블을 생성하는 데 사용할 수 있다.

```kotlin
@Database(entities = [ Crime::class ], version = 1)
abstact class CrimeDatabase : RoomDatabase() {
}
```

@Database 애노테이션은 이 클래스가 앱의 데이터베이스를 나타낸다고 Room에 알려준다. 이 애노테이션은 두개의 매개변수를 가진다.

- 첫 번째 매개변수 → 이 데이터베이스의 테이블들을 생성하고 관리하는 데 사용할 엔티티 클래스들 지정
- 두 번째 매개변수 → 데이터베이스의 버전 지정

### 타입 변환기 생성하기

Room은 내부적으로 SQLite 사용

- SQLite(Structured Query Language) → 오픈소스 관계형 데이터베이스, 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장

Room은 코틀린 객체와 데이터베이스 사이에서 객체-관계 매핑(ORM, Object-Relational Mapping) 계층의 역할을 하면서 SQLite 사용을 쉽게 해준다.

Roo은 기본 데이터 타입을 SQLite 데이터베이스 테이블에 쉽게 저장할 수 있지만, 이외의 다른 타입은 문제가 생길 수 있다. 

- 다른 타입의 경우 데이터베이스 테이블에 저장하거나 가져오는 방법을 Room에게 알려주어야 한다.

**타입 변환기**

- Room에게 특정 타입을 데이터베이스에 저장되는 타입으로 변환하는 방법을 알려준다.

```kotlin
//@TypeConverter 애노테이션이 지정된 두개의 함수 필요
// 데이터베이스에 데이터를 저장하기 위해 타입을 변환하는 함수
// 데이터베이스로부터 읽은 데이터를 우리가 원하는 타입으로 변환하는 ㅎ마수

class CrimeTypeConverters {
	@TypeConverter
	fun fromDate(date: Date?): Long? {
			return date?.time
	}

	@TypeConverter
	fun toDate(millisSinceEpoch: Long?): Date? {
			return millisSinceEpoch?.let {
			}
	}
```

## DAO 정의하기

**DAO(Data Access Object)**

- 데이터베이스 테이블의 데이터를 액세스 하기위해 생성
- 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스

```kotlin
@Dao
interface CrimeDao {
	
	@Query("SELECT * FROM crime")
	fun getCrimes(): List<Crime>

  @Query("SELECT * FROM WHERE id=(:id)")
	fun gtCrime(id: UUID): Crime?
}
//@Query -> 문자열로된 SQL 명령을 받는다.
```

## 리포지터리 패턴으로 데이터베이스 액세스하기

리포지터리 클래스

- 단일 또는 여러 소스로부터 데이터를 액세스하는 로직 캡슐화, 로컬 데이터베이스나 원격 서버로부터 득정 데이터셋을 가져오거나 저장하는 방법을 결정

```kotlin
class CrimeRepository private constructor(context: Context) {
	
	companion object {
			private var INSTANCE: CrimeRepository? = null
			
			fun initialize(context: Context) {
					if (INSTANCE == null) {
							INSTANCE = CrimeRepository(context)
					}
			
			fun get(): CrimeRepository {
					return INSTANCE ?:
					throw IllegalStateException()
			}
		}
}
```

CrimeRepository는 **싱글톤**

- 앱이 실행되는 동안 하나의 인스턴스만 생성된다.

> 싱글톤은 앱이 메모리에 있는 한 계속 존재하므로, 싱글톤이 갖는 속성은 액티비티나 프래그먼트의 생명주기 상태가 변경되어도 계속 유지될 수 있다. 

안드로이드 운영체제가 메모리에서 앱을 제거하면 싱글톤도 같이 소멸된다.
> 

```kotlin
class CriminalIntentApplication : Application() {
	
// 앱이 최초로 메모리에 로드될 때 안드로이드 시스템이 자동 호출
// 한번만 초기화되는 작업을 수행하는데 적합
// Application 인스턴스는 앱이 최초 실행될 때 생성되거나 앱 프로세스 소멸로 인해 인스턴스가 소멸된 후 앱이 다시 실행될 때 재생성
	override fun onCreate() {
		super.onCreate()
		CrimeRepository.initialize(this)
	}
}
```

```kotlin
private const val DATABASE_NAME = "crime-database"

class CrimeRepository private constructor(context: Context) {
	
	// Room.databaseBuilder() 세 개의 매개변수를 사용해서 database의 실체 클래스 생성
	// 첫 번째 매개변수 -> 데이터베이스의 컨텍스트
	// 두 번째 매개변수 -> Room으로 생성하고자 하는 데이터베이스 클래스 
	// 세 번째 매개변수 -> Room으로 생성하고자 하는 데이터베이스 파일 이름
	private val database : CrimeDatabase = Room.databaseBuilder(
			context.applicationContext, 
			CrimeDatabase::class.java,
			DATABASE_NAME
	).build()

	private val crimeDao = database.crimeDao()

	companion object {
	}
}
```

## 쿼리 테스트하기

### 테스트 데이터베이스 업로드하기

안드로이드 장치의 각 애플리케이션은 자신의 샌드박스에 디렉터리를 갖는다. 샌드박스에 파일을 저장하면 다른 애플리케이션이나 호기심 많은 다른 사용자가 액세스하는 것을 막아준다.

## 애플리케이션의 스레드

Room은 메인 스레드에서의 데이터베이스 액세스를 허용하지 않으며, 액세스하려고 하면 IllegalStateException을 발생시킨다.

**스레드**

- 단일의 실행 시퀀스
- 스레드 내부의 코드는 한 단계씩 실행된다.
- 모든 안드로이드 앱은 main 스레드로 시작된다.
- main 스레드는 미리 정해진 순서로 실행되지 않는다. 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다린다. 이벤트가 발생하면 응답하는 코드를 실행한다.

**main 스레드**

- UI를 변경하는 모든 코드를 실행
- 서로 다른 UI 관련 이벤트들에 대한 응답으로 실행되는 코드들도 포함
- UI 스레드

### 백그라운드 스레드

**ANR(Application Not Responding, 애플리케이션이 응답하지 않는)**

- 데이터베이스 액세스는 다른 일보다 시간이 많이 걸려서 이 시간 동안 UI는 완전히 응답이 블가능이 되는 상태
- 10초 이내에 UI 응답이 없으면 사용자가 불편하지 않도록 안드로이드 시스템에서 ANR 발생시킨다.

**백그라운드 스레드** 

- 장기간 실행되는 모든 작업은 백그라운드 스레드로 수행되어야 한다.
- UI는 메인스레드

## LiveData 사용하기

**LiveData**

- 앱의 서로 다른 부분 간에 데이터 전달을 쉽게 만드는 것
- 스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main 스레드로 데이터 전달할 수 있다.

Room DAO 쿼리에서 LiveData를 반환하도록 구성하면, Room이 백그라운드 스레드에서 쿼리작업을 자동 실행한 후 그 결과를 LiveData 객체로 반환된다. 따라서 액티비티나 프래그먼트에서는 LiveData 객체를 관찰하도록 설정만 하면 된다.

### LiveData 관찰하기

```kotlin
class CrimeListFragment : Fragment() {
	
	...
	override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
		super.onViewCreated(view, savedInstanceState)
		// LiveData 인스턴스에 옵저버를 등록하기 위해 사용
		crimeListViewModel.crimeListLiveData.observe(
			viewLifecycleOwner,
			Observer { crimes ->
				crimes?.let {
					Log.i(TAG, "Got crimes ${crimes.size}")
					updateUI(crimes)
				}
			})
	}
	// viewLifecycleOwner를 전달하므로 옵저버의 실행이 프래그먼트 자신이 아닌 프래그먼트 뷰의 생명주기와 연동된다.
	// 프래그먼트 뷰의 생명주기는 프래그먼트 인스턴스의 생명주기와 별개지만 프래그먼트의 생명주기를 반영
}
```

observe(…) 함수의 첫 번째 인자

- viewLifeCycleOwner는 코틀린 속성
    - viewLifeCycleOwner는 프래그먼트 뷰의 생명주기를 나타내는 LifecyclerOwner 구현 객체를 반환
    - CrimeListFragment의 뷰의 생명주기에 맞춰 옵저버가 LiveData 인스턴스의 변경을 관찰하고 변경이 생기면 실행된다.

observe(…) 함수의 두 번째 인자

- Observer 인터페이스를 구현하는 객체, 옵저버이며 람다식으로 구현
- LiveData의 새로운 데이터를 처리

LiveData의 변경이 생길 때마다 옵저버가 실행되면 프래그먼트의 뷰가 유효한 상태가 아닌 때에도 변경이 되면 결국 앱이 중단되기 때문에 함수의 첫 번째 인자로 LifecyclerOwner 객체를 지정하는 것이다. 이렇게 하면 옵저버의 생명주기는 지정한 LifecyclerOwner 객체가 나타내는 안드로이드 컴포넌트의 생명주기에 한정된다.

**생명주기-인식 컴포넌트(lifecycler-aware component)**

- 프래그먼트 뷰의 생명주기에 따라 반응하는 컴포넌트

LifecycleOwner 인터페이스를 구현하는 객체는 Lifecycle 객체를 포함

Lifecycle은 안드로이드 생명주기의 현재 상태를 유지 관리하는 객체

생명주기 상태는 Lifecycle.State에 정의되어 있으며, Lifecycle.getCurrentState()를 사용하면 Lifecycle 객체의 상태를 알 수 있다.

## 궁금증 해소하기: 싱글톤

**싱글톤**

- 프래그먼트나 액티비티보다 더 오래 존재한다.
- 장치를 회전시키더라도 여전히 존재, 앱의 액티비티와 프래그먼트를 오갈 때도 계속 남는다.
- 단점
    - 싱글톤도 자신의 생애가 있기 때문에 장기간에 걸쳐 데이터를 저장할 수 있는 방법은 아니며, 데이터를 디스크에 쓰거나 웹 서버로 전송하는 것만이 해결책
    - 코드의 단위 테스트를 어렵게 만들 수 있다. → 의존성 주입으로 문제 해결
    - 잘못 사용될 수 있다.
