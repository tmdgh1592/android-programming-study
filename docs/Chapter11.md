# 📖 데이터베이스와 Room 라이브러리

### Room 아키텍처 컴포넌트 라이브러리

- Room은 Jetpack의 아키텍처 컴포넌트 라이브러리로, 데이터베이스 설정과 사용을 쉽게 해준다.
- Room을 사용하면 애노테이션이 지정된 코틀린 클래스로 데이터베이스 구조와 쿼리를 정의할 수 있다.
- Room은 API, 애노테이션(annotation), 컴파일러로 구성되어 있다.
- 데이터베이스를 정의하고 인스턴스를 생성하기 위해 상속받는 클래스들이 API에 포함되어 있다.
- 그리고 데이터베이스에 저장할 필요가 있는 클래스, 데이터베이스를 나타내는 클래스, 데이터베이스 테이블을 사용하는 함수들을 정의하는 클래스 등을 나타내기 위해 애노테이션을 사용한다.
- 컴파일러는 지정한 애노테이션을 컴파일해서 데이터베이스 구현체(클래스나 인터페이스 등)를 생성한다.

### kotlin-kapt

- `kotlin-kapt` 는 코틀린 애노테이션 처리 도구(Kotlin annotation processor tool)다.
- `kotlin-kapt` 플러그인을 추가하면 라이브러리가 생성한 클래스들을 안드로이드 스튜디오에서 알 수 있으므로 import해서 사용할 수 있다.

### Room 라이브러리 의존성 추가

- `room-runtime`
  - 데이터베이스를 정의하는 데 필요한 모든 클래스와 애노테이션을 포함하는 Room API다.
- `room-compiler`
  - 지정한 애노테이션을 컴파일해서 데이터베이스 구현체를 생성한다.
  - 의존성을 지정할 때 `implementation` 대신 `kapt` 키워드를 사용해 Room 컴파일러가 생성한 클래스들을 안드로이드 스튜디오가 알 수 있게 한다.

### 엔티티(Entity)

- Room은 **엔티티**를 기반으로 앱의 데이터베이스 테이블 구조를 만든다.
- 엔티티는 우리가 생성하는 모델 클래스로, **@Entity** 애노테이션으로 지정한다.
- **@Entity** 애노테이션은 클래스 수준에 적용된다.
- **@Entity** 애노테이션은 해당 클래스가 데이터베이스 테이블의 구조를 정의함을 나타낸다.
- 따라서 테이블의 각 행(row)이 하나의 객체를 나타내며, 클래스에 정의된 각 속성은 테이블의 열(column)이므로 속성 이름은 열의 이름이 된다.

### @PrimaryKey

- **@PrimaryKey** 애노테이션은 **기본 키(primary key)** 열을 지정한다.
- 기본 키는 테이블의 모든 행에 고유한 데이터를 갖는 열이므로 각 행을 검색하는 데 사용할 수 있다.

### @Database

- **@Database** 애노테이션은 이 클래스가 앱의 데이터베이스를 나타낸다고 Room에게 알려준다.
- 지정해야 하는 매개변수
  - 첫 번째 매개변수에는 이 데이터베이스의 테이블들을 생성하고 관리하는 데 사용할 엔티티 클래스들을 지정한다.
  - 두 번째 매개변수에는 데이터베이스의 버전을 지정한다.
    - 데이터베이스를 처음 생성했을 때는 버전이 1이다.
    - 그리고 앱을 계속 개발하는 동안 엔티티를 추가하거나 기존 엔티티에 새로운 속성을 추가할 경우 **@Database** 애노테이션의 엔티티들을 변경하거나 데이터베이스 버전 번호를 증가시켜야 한다.

### SQLite

- Room은 내부적으로 SQLite를 사용한다.
- SQLite는 오픈 소스 관계형 데이터베이스다.
  - SQL은 Structured Query Language의 약어이며 표준 데이터베이스 언어다.
- 다른 데이터베이스와 달리 SQLite는 라이브러리를 사용해서 데이터를 읽거나 데이터를 쓸 수 있는 파일에 저장한다.
- 안드로이드는 추가 도우미 클래스들과 함께 SQLite 라이브러리를 표준 라이브러리에 포함하고 있다.
- Room은 코틀린 객체와 데이터베이스 사이에서 객체-관계 매핑(ORM, Object-Relational Mapping) 계층의 역할을 하면서 SQLite 사용을 쉽게 해준다.
- Room은 기본 데이터 타입을 SQLite 데이터베이스 테이블에 쉽게 저장할 수 있지만, 이외의 다른 타입은 문제가 생길 수 있다.
  - 따라서 이런 타입의 데이터를 데이터베이스 테이블에 저장하거나 가져오는 방법을 Room에게 알려주어야 한다.

### 타입 변환기

- 데이터 타입을 변환하는 방법을 Room에게 알려주려면 **타입 변환기**를 지정하면 된다.
- 타입 변환기는 Room에게 특정 타입을 데이터베이스에 저장되는 타입으로 변환하는 방법을 알려준다.
- 이때 각 타입에 대해서 **@TypeConverter** 애노테이션이 지정된 두 개의 함수가 필요한데, 데이터베이스에 데이터를 저장하기 위해 타입을 변환하는 함수와 데이터베이스로부터 읽은 데이터를 우리가 원하는 타입으로 변환하는 함수다.
- 데이터베이스 클래스에 **@TypeConverters** 애노테이션을 추가하면서 컨버터 클래스를 전달하면 Room은 타입을 변환할 때 해당 클래스의 함수들을 사용한다.

### DAO(Data Access object)

- 데이터베이스 테이블의 데이터를 액세스하려면 DAO를 생성해야 한다.
- DAO는 데이터베이스 작업을 수행하는 함수들을 포함하는 인터페이스다.
- **@Dao** 애노테이션을 지정하면 해당 인터페이스가 DAO 중 하나임을 Room이 알게 된다.
- 그리고 데이터베이스 클래스에 등록하면 이 인터페이스에 추가된 함수들의 실행 코드를 Room이 생성한다.
  - Dao로 반환 타입으로 갖는 추상 함수를 데이터베이스 클래스에 추가한다.
  - 그러면 Room은 데이터베이스가 생성되면 Dao 구현 클래스를 생성한다.
  - 따라서 Dao 참조를 가지면 Dao에 정의된 함수들을 호출해서 데이터베이스를 사용할 수 있다.
- Dao는 **@Query** 애노테이션이 추가된 함수를 가진다.
- **@Query** 애노테이션은 해당 함수가 데이터베이스의 데이터를 읽는다는 것을 나타낸다(추가, 변경, 삭제가 아님).
- 이 DAO에 정의된 각 쿼리 함수의 반환 타입은 쿼리가 반환하는 결과의 타입을 반영한다.
- **@Query** 애노테이션은 문자열로 된 SQL 명령을 받는다.

### Repository 패턴

- Repository 클래스는 Repository(데이터 저장소)를 구현한다.
- 또한 단일 또는 여러 소스로부터 데이터를 액세스하는 로직을 캡슐화하고, 로컬 데이터베이스나 원격 서버로부터 특정 데이터셋을 가져오거나 저장하는 방법을 결정한다.
- 그리고 UI 코드에서는 Repository에 모든 데이터를 요청한다.
- UI는 어떻게 데이터를 저장하거나 가져오는지에 관여하지 않으므로 이런 일은 Repository에서 구현한다.

### Room.databaseBuilder()

- 새 개의 매개변수를 사용해서 데이터베이스의 실체 클래스를 생성한다.
  - 데이터베이스가 안드로이드 장치의 파일 시스템을 액세스하므로 첫 번째 매개변수는 데이터베이스의 컨텍스트로, 주로 앱의 Context 객체를 전달한다.
  - 두 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 클래스이다.
  - 세 번째 매개변수는 Room으로 생성하고자 하는 데이터베이스 파일 이름이다.
    - SQLite에서는 한 데이터베이스가 하나의 파일로 생성된다.

### 애플리케이션 스레드

- Room은 메인 스레드에서의 데이터베이스 액세스를 허용하지 않으며, 액세스하려고 하면 `IllegalStateException` 을 발생시킨다.
- 스레드는 단일의 실행 시퀸스다.
- 스레드 내부의 코드는 한 단계씩 실행된다.
- 모든 안드로이드 앱은 **main 스레드**로 시작된다.
- 그러나 main 스레드는 미리 정해진 순서로 실행되지 않는다.
- 대신에 무한 루프에 머물면서 사용자나 시스템이 유발한 이벤트를 기다린다. 그리고 이벤트가 발생하면 응답하는 코드를 실행한다.
- main 스레드는 UI를 변경하는 모든 코드를 실행하며, 액티비티 시작, 버튼 누름 등 서로 다른 UI 관련 이벤트들에 대한 응답으로 실행되는 코드들도 포함된다.
- 이벤트들은 어떤 형태로든 모두 UI와 관련이 있어서 main 스레드를 **UI 스레드**라고도 한다.
- 이벤트 루프에서는 UI 코드를 순서대로 유지한다.
  - 따라서 시기 적절하게 코드가 실행되면서도 상호 충돌이 생기지 않는다.

### ANR(**Application Not Responding)**

- 만약 데이터베이스 접근과 같은 긴 시간의 작업을 main 스레드에서 할 경우, 이 시간 동안 UI는 완전히 응답 불가능이 될 것이고, 결국 **애플리케이션이 응답하지 않는(Application Not Responding, ANR)** 결과를 초래하게 된다.
- main 스레드가 중요한 이벤트에 대한 응답에 실패했다고 안드로이드의 와치독(watchdog)이 판단하면 ANR이 발생하며 애플리케이션이 중단된다.
- 10초 이내에 UI 응답이 없으면 사용자가 불편하지 않도록 안드로이드 시스템에서 ANR을 발생시킨다.

### 백그라운드 스레드

- 백그라운드 스레드를 생성해서 데이터베이스를 액세스하면 ANR 발생을 막을 수 있다.
- 백그라운드 스레드를 앱에 추가할 때 고려할 중요한 규칙이 두 가지 있다.
  - 장시간 실행되는 모든 작업은 백그라운드 스레드로 수행되어야 한다.
  - UI는 main 스레드에서만 변경할 수 있다.
    - 백그라운드 스레드에서 UI를 변경하려고 하면 에러가 발생한다.
- 안드로이드에서 백그라운드 스레드로 작업을 실행하는 방법
  - 비동기 네트워크를 요청
  - 핸들러(Handler)를 사용해서 많은 소규모 백그라운드 작업을 수행
  - WorkManager를 사용해서 주기적인 백그라운드 작업을 수행하는 방법

### LiveData

- LiveData는 Jetpack의 `lifecycle-extensions` 라이브러리에 있는 데이터 홀더 클래스이며, Room에서 LiveData를 사용한다.

- LiveData의 목적은 

  앱의 서로 다른 부분 간에 데이터 전달을 쉽게 만드는 것

  이다.

  - 예를 들어 Repository에서 액티비티 또는 프래그먼트로 데이터를 전달하는 경우가 있다.

- LiveData는 스레드 간에도 데이터를 전달할 수 있어서 백그라운드 스레드에서 main 스레드로 데이터를 전달할 수 있다.

- **Room DAO의 쿼리에서 LiveData를 반환하도록 구성하면, Room이 백그라운드 스레드에서 쿼리 작업을 자동 실행한 후 그 결과를 LiveData 객체로 반환한다.**

- 따라서 액티비티나 프래그먼트에서는 LiveData 객체를 관찰하도록 설정만 하면 된다.

- 그리고 LiveData 객체가 준비되면 main 스레드의 액티비티나 프래그먼트에 통보되므로 이때 LiveData를 사용해서 데이터를 처리하면 된다.

- `LiveData.observe` 함수는 LiveData 인스턴스에 옵저버를 등록하기 위해 사용된다.

  - 첫 번재 인자로 지정된 `viewLifecycleOwner` 는 코틀린 속성이며, `androidx.fragment.app.fragment` 의 `getViewLifecycleOwner()`  함수를 호출하는 것과 같다.
    - `viewLifecycleOwner` 는 프래그먼트 뷰의 생명주기를 나타내는 LifecycleOwner 구현 객체를 반환한다.
    - 따라서 프래그먼트의 생명주기가 아닌 프래그먼트의 뷰의 생명주기에 맞춰 옵저버가 LiveData 인스턴스 변경을 관찰하고 변경이 생기면 실행된다.
    - 그렇기 때문에 프래그먼트의 뷰가 유효한 상태일 때만 LiveData 객체가 옵저버에게 변경을 통보해 UI를 변경할 수 있다.
    - 즉, 프래그먼트 뷰의 LifecycleOwner 객체를 사용하면 뷰가 화면에 보이지 않을 때는 LiveData의 변경 데이터를 받지 않는다.
    - 이처럼 LiveData는 프래그먼트 뷰의 생명주기에 따라 반응해서 이런 컴포넌트를 **생명주기-인식 컴포넌트(lifecycle-aware component)**라고 한다.
  - 두 번째 인자는 Observer 인터페이스를 구현하는 객체, 즉 옵저버이며 여기서는 람다식으로 구현되었다.
    - 옵저버는 LiveData의 새로운 데이터를 처리한다.

### LifecycleOwner

- LifecycleOwner 인터페이스를 구현하는 객체는 Lifecycle 객체를 포함한다.
- Lifecycle은 안드로이드 생명주기의 현재 상태를 유지 관리하는 객체다.
  - 액티비티, 프래그먼트, 뷰, 심지어는 앱 자체도 자신의 생명주기를 갖는다.
- `생성` 이나 `실행 재개` 와 같은 생명주기 상태는 `Lifecycle.State` 열거형(enum)에 정의되어 있으며, `Lifecycle.getCurrentState()` 를 사용하면 Lifecycle 객체의 상태를 알 수 있다.
- AndroidX의 Fragment 클래스는 LifecycleOwner 인터페이스를 구현하며, 프래그먼트 인스턴스의 생명주기 상태를 나타내는 Lifecycle 객체를 갖고 있다.
- 프래그먼트 뷰의 생명주기는 **FragmentViewLifecycleOwner**가 별개로 유지 및 관리한다.
- 각 프래그먼트는 자신의 뷰의 생명주기를 유지 및 관리하는 **FragmentViewLifecycleOwner** 인스턴스를 갖는다.

### 싱글톤

- 싱글톤은 프래그먼트나 액티비티보다 더 오래 존재한다.
- 또한 싱글톤은 장치를 회전시키더라도 여전히 존재하며 앱의 액티비티와 프래그먼트를 오갈 때도 계속 남는다.
- 싱글톤을 사용하면 모델 객체를 소유하는 클래스를 편리하게 만들 수 있다.
- 단점
  - 싱글톤은 컨트롤러보다 더 오랜 생애 동안 데이터를 저장하게 해주지만 싱클톤 자신도 생애가 있다.
    - 즉, 앱이 종료된 후 어떤 시점에서 안드로이드 운영체제가 메모리를 회수하면 싱글톤은 자신의 인스턴스 변수와 함께 소멸된다.
    - 따라서 싱글톤은 장기간에 걸쳐 데이터를 저장할 수 있는 방법은 아니며, 데이터를 디스크에 쓰거나 웹 서버로 전송하는 것만이 해결책이다.
  - 싱글톤은 코드의 단위 테스트를 어렵게 만들 수 있다.
    - 안드로이드 개발자들은 주로 **의존성 주입(dependency injection)**으로 이 문제를 해결한다.
    - 이렇게 하면 객체들을 싱글톤으로 공유할 수 있다.
  - 싱글톤은 잘못 사용될 수 있다.
    - 편리하다고 아무 생각 없이 모든 것에 싱글톤을 사용하려고 할 수 있다.
    - 왜냐하면 싱글톤은 코드 어디서나 사용할 수 있으며, 나중에 사용할 데이터가 어떤 것이든 싱글톤에 저장할 수 있기 때문이다.
    - 그러나 `이 데이터는 어디에 사용되는가? 이 기능이 중요한 곳은 어디인가?` 라는 매우 중요한 질문을 스스로에게 해야 한다.