# 8️⃣ UI 프래그먼트와 프래그먼트 매니저

### UI 유연성

- UI 유연성이란 사용자나 장치가 요구하는 것에 따라 런타임 시에 액티비티의 뷰를 구성하거나 변경할 수 있는 능력이다.
  - 예를 들면 세로 방향에서는 두 화면을 따로 보여주다가 가로 방향일 때는 한 화면에서 한 번에 보여주는 경우가 존재한다.
- 액티비티는 UI 유연성으 제공하도록 설계되지 않았다.
  - 액티비티의 뷰들은 런타임 시에 변경되며, 이 뷰들을 제어하는 코드는 액티비티 내부에 있어야 한다.
  - 따라서 액티비티는 사용하는 특정 화면과 강하게 결합되어 있다.
- 하나 이상의 프래그먼트로 앱의 UI를 관리하면 유연성이 좋아진다.

### 프래그먼트

- 프래그먼트는 액티비티의 작업 수행을 대행할 수 있는 컨트롤러 객체다.
  - 여기서 작업이란 UI 관리를 말하며, UI는 화면 전체 또는 일부분이 될 수 있다.
- UI를 관리하는 프래그먼트를 UI 프래그먼트라 한다.
  - UI 프래그먼트는 레이아웃 파일로부터 인플레이트(inflate)되는 자신의 뷰를 하나 갖는다.
  - 프래그먼트의 뷰는 사용자가 보면서 상호 작용하기를 원하는 UI 요소들을 포함한다.
- 이때 액티비티 뷰는 자신의 UI를 갖는 대신 프래그먼트를 넣을 컨테이너를 가지며, 이 컨테이너에는 인플레이트된 프래그먼트의 뷰가 추가된다.
  - 액티비티는 하나 이상의 프래그먼트 뷰를 수용하는 다수의 컨테이너를 가질 수 있다.
- 액티비티에서 프래그먼트를 교체하여 뷰가 변경되더라도 액티비티는 소멸하지 않는다.
- UI 프래그먼트를 사용하면 앱의 UI를 조립 가능한 요소로 분리할 수 있어서 유용하며, 탭 인터페이스를 비롯한 여러 가지를 쉽게 만들 수 있다.
- 안드로이드 Jetpack API 중에서도 프래그먼트를 잘 활용하는 API가 있기 때문에 함께 사용하면 유용하다.
- 화면은 UI 프래그먼트가 관리하며, 프래그먼트 인스턴스는 액티비티가 호스팅한다.
  - 액티비티는 자신의 뷰 계층 구조에 프래그먼트와 그 뷰를 포함하는 곳을 제공하는데, 이것을 호스팅이라고 생각하면 된다.
  - 프래그먼트는 화면에 보이는 뷰를 자체적으로 가질 수 없으며, 액티비티의 뷰 계층에 추가될 때만 화면에 자신의 뷰가 보인다.
- UI 프래그먼트 생성
  - 레이아웃 파일에 위젯들을 정의해 UI를 구성한다.
  - 클래스를 생성하고 정의된 레이아웃을 이 클래스의 뷰로 설정한다.
  - 레이아웃으로부터 인플레이트된 위젯들을 코드에 연결한다.
- 프래그먼트의 생명주기 함수는 모두 `public` 이어야 한다.
  - 프래그먼트를 호스팅하는 어떤 액티비티에서도 자동 호출될 수 있어야 하기 때문이다.
- 프래그먼트는 액티비티와 동일하게 자신의 상태 데이터를 저장하거나 가져오는 `Bundle` 객체를 갖는다.
- 프래그먼트는 액티비티와 달리 `onCreate` 에서 뷰를 인플레이트하지 않고 `onCreateView(LayoutInflater, ViewGroup?, Bundle?)` 에서 뷰를 인플레이트한다.
  - 이때 인플레이트된 뷰를 호스팅 액티비티에 반환해야 한다.
  - `LayoutInflater` 와 `ViewGroup` 매개변수는 레이아웃을 인플레이트 하기 위해 필요하다.
  - `Bundle` 은 저장된 상태 데이터를 가지며, 뷰를 재생성하는데 사용된다.

### 안드로이드 UUID

- UUID(Universally Unique Identifier)는 안드로이드 프레임워크에 포함된 유틸리티 클래스다.
- UUID는 128bit의 고유한 값이다.
- 이 클래스는 고유한 ID 값을 쉽게 생성하는 방법을 제공한다.
- `UUID.randomUUID()` 를 호출하면 임의의 UUID 값을 갖는 고유 ID를 쉽게 생성할 수 있다.

### 프래그먼트 뷰 인플레이트

- ```
  inflater.inflate(R.layout.fragment_crime, container, false)
  ```

  - 첫 번째 인자로는 레이아웃 리소스 ID를 전달해 `LayoutInflater.inflate(...)` 를 호출함으로써 프래그먼트의 뷰를 명시적으로 인플레이트한다.
  - 두 번째 인자는 위젯들을 올바르게 구성하는 데 필요한 뷰의 부모다.
  - 세 번째 인자는 인플레이트된 뷰를 이 뷰의 부모에게 즉시 추가할 것인지를 `LayoutInflater` 에 알려준다.
    - 액티비티의 컨테이너 뷰에 프래그먼트 뷰를 호스팅하며 프래그먼트 뷰가 인플레이트되는 즉시 부모 뷰에 추가될 필요 없이 액티비티가 나중에 뷰를 추가하므로 `false` 를 전달하면 된다.

### UI 프래그먼트 호스팅

- UI 프래그먼트 호스팅하려면 액티비티는 다음 두 가지를 수행해야 한다.
  - 액티비티의 레이아웃에 프래그먼트의 뷰를 배치할 곳을 정의해야 한다.
  - 프래그먼트 인스턴스의 생명주기를 관리해야 한다.

### FragmentManager

- FragmentManager는 프래그먼트 리스트와 프래그먼트 트랜잭션의 백 스택(back stack)을 처리한다.
- FragmentManager는 프래그먼트의 뷰를 액티비티의 뷰 계층에 추가하고 프래그먼트의 생명주기를 주도하는 책임을 갖는다.
- 프래그먼트 트랜잭션
  - 프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가(add), 삭제(remove), 첨부(attach), 분리(detach), 변경(replace) 하는데 사용된다.
  - 프래그먼트 트랜잭션을 사용하면 여러 개의 오퍼레이션(트랜잭션으로 실행되는 각 함수 코드)을 묶어서 수행할 수 있다.
    - 예를 들어, 다수의 프래그먼트를 동시에 서로 다른 컨테이너에 추가하는 경우다.
- FragmentManager는 프래그먼트 트랜잭션의 백 스택을 유지 관리한다.
  - 따라서 프래그먼트 트랜잭션이 다수의 오퍼레이션을 포함한다면 해당 드랜잭션이 백 스택에서 제거될 때 이 오퍼레이션들이 역으로 실행된다.
  - 그러므로 다수의 프래그먼트 오퍼레이션들을 하나의 트랜잭션으로 묶으면 UI 상태를 더욱 자라 제어할 수 있다.

```kotlin
val fragment = CrimeFragment()
supportFragmentManager
	.beginTransaction()
	.add(R.id.fragment_container, fragment)
	.commit()
```

- `FragmentManager.beginTransaction()` 함수는 `FragmentTransaction` 의 인스턴스를 생성해 반환한다.

  - `FragmentTransaction` 클래스는 **플루언트 인터페이스(fluent interface)**를 사용한다.
  - 플루언트 인터페이스는 코드를 이해하기 쉽게 해주는 객체지향 기법이며, 일반적으로 함수의 연쇄 호출 형태로 구현된다.
  - 즉, `FragmentTransaction` 을 구성하는 함수들이 Unit 대신 `FragmentTransaction` 객체를 반환하기 때문에 이 함수들을 연쇄 호출할 수 있다.
  - 코틀린 Unit은 하나의 인스턴스만 생성되는 싱글톤 객체이며 자바의 void와 같이 함수의 반환 값이 없음을 나타내는 데 사용된다.

- `add` 함수는 컨테이너 뷰 ID와 프래그먼트 인스턴스를 매개변수로 갖는다.

  - 컨테이너 뷰 ID는 액티비티 xml에 정의한 `FrameLayout` 의 리소스 ID다.

  - 컨테이너 뷰 ID는 다음 두 가지 목적으로 사용된다.

    - 액티비티 뷰의 어느 위치에 프래그먼트 뷰가 나타나야 하는지를 FragmentManager에 알려준다.

    - FragmentManager의 리스트에서 프래그먼트를 고유하게 식별하는 데 사용된다.

      ```kotlin
      val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_container)
      ```

- 액티비티가 소멸될 때 `FragmentManager` 인스턴스는 해당 액티비티의 프래그먼트 리스트를 보존한다.

  - 해당 액티비티가 다시 생성되면 새로운 `FragmentManager` 인스턴스가 그 리스트를 가져와서 리스트에 있는 프래그먼트를 다시 생성해 이전 상태로 복원한다.

### FragmentManager와 프래그먼트 생명주기

- 프래그먼트 생명주기와 액티비티 생명주기 차이점
  - 프래그먼트 생명주기 함수는 안드로이드 운영체제가 아닌 호스팅 액티비티의 `FragmentManager` 가 호출한다.
  - 프래그먼트는 액티비티가 내부적으로 처리해서 안드로이드 운영체제는 액티비티가 사용하는 프래그먼트에 관해서 아무것도 모른다.
- 프래그먼트를 `FragmentManager` 에 추가할 때 호출되는 생명주기 함수
  - `onAttach`, `onCreate`, `onCreateView`, `onViewCreated`

### 프래그먼트 사용 시 주의할 점

- 프래그먼트는 주요 컴포넌트를 재사용 할 수 있게 해준다.
- 하지만 만약 한번에 너무 많은 프래그먼트를 화면에 넣는다면, 프래그먼트 트랜잭션 때문에 코드가 지저분해질 수 있다.
- 따라서 작은 컴포넌트들을 재사용할 때는 프래그먼트 대신 커스텀 뷰로 추출하는 것이 좋다.
- 일반적으로 한 화면에는 최대 두 개 또는 세 개 정도의 프래그먼트를 사용하는 것이 좋다.