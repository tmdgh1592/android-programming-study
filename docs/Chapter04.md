# 4️⃣ UI 상태 유지하기

<aside> 💡 장치 회전과 같은 런타임 구성 변경 시에 데이터를 보존할 방법이 필요하다. 또한, 프로세스 종료에 따른 UI 상태 유실을 방지하기 위해 안드로이드의 인스턴스 상태 보존 메커니즘을 사용할 수 있다.</aside>

### ViewModel 의존성 추가

app 모듈 빌드 파일에 `lifecycle-extensions` 라이브러리 의존성을 추가한다.

### androidx.lifecycle 패키지

- 제공
  - 생명주기를 인식하는 컴포넌트
    - 액티비티와 같은 다른 컴포넌트의 생명주기를 관찰하고 상태를 고려해 작동한다.
    - 대표적으로 LiveData가 있다.
  - 생명주기 관련 API
  - ViewModel

### ViewModel

- 기능
  - 모델 데이터를 화면에 보여주는 기능을 수행한다.
  - ViewModel을 사용하면 화면에서 필요한 모든 데이터를 한곳에서 종합하고 데이터를 형식화할 수 있다.
    - 따라서 프레젠테이션 로직 코드를 액티비티와 분리할 수 있어서 액티비티를 비교적 가볍게 유지할 수 있다.
    - 액티비티에 추가되는 모든 코드는 의도치 않게 액티비티 생명주기의 영향을 받을 수 있기 때문에 가능하다면 액티비티를 가볍게 유지하는 것이 좋다.
    - 또한, 가볍게 유지하면 액티비티는 화면에 나타나는 것을 처리하는 것에만 집중할 수 있고 보여줄 데이터를 결정하는 내부 로직은 신경 쓰지 않아도 된다.
- 생명주기
  - ViewModel 인스턴스는 액티비티 생명주기와 연동된다.
  - 생명주기를 같이하는 액티비티가 소멸되면 ViewModel 인스턴스도 함께 메모리에서 제거된다.
  - 인스턴스가 소멸되기 전 `onCleared()` 함수가 호출된다.
- 상황
  - 액티비티의 속성 중 하나인 `isFinishing`이 `true`면 사용자가 액티비티를 끝냈음을 의미하고, UI 상태를 보존할 필요가 없다.
  - 반면, 액티비티의 속성 중 하나인 `isFinishing`이 `false`면 장치 구성 변경으로 인해 시스템이 현재 액티비티의 인스턴스를 소멸시킨다는 것을 의미하므로 UI 상태를 보존할 필요가 있다.
- ViewModel을 사용하면 다른 방법을 사용하지 않아도 액티비티의 UI 상태 데이터를 메모리에 보존할 수 있다.
  - ViewModel은 장치의 구성 변경이 생겨도 계속 존재하다가 액티비티가 종료될 때만 소멸되기 때문이다.
- View와의 관계
  - View와 ViewModel의 관계는 단방향이다.
  - 즉, View는 ViewModel을 참조하지만 ViewModel은 View를 참조하지 않는다.
  - ViewModel가 View를 참조하면 **메모리 유실(memory leak)**이 생길 수 있다.
  - 메모리 유실 상황 및 문제점
    - 장치 회전 시에 액티비티 인스턴스는 소멸되지만, ViewModel 인스턴스는 메모리에 남는다.
    - 만약 ViewModel 인스턴스가 액티비티 인스턴스에 대해 강한 참조를 가지면 다음과 같은 문제가 발생할 수 있다.
      - 액티비티 인스턴스가 메모리에서 제거되지 않아서 이 인스턴스가 사용하는 메모리가 유실된다.
      - ViewModel 인스턴스가 현재 사용되지 않는 과거 액티비티의 참조를 갖게 되어 ViewModel 인스턴스가 과거 액티비티의 뷰를 변경하려고 하면 `IllegalStateException`이 발생한다.

### 메모리 유실

- 발생상황
  - 소멸되어야 하는 객체의 참조를 다른 객체가 가지면 발생할 수 있다.
- 이유
  - 참조되는 객체를 가비지 컬렉터가 메모리에서 제거할 수 없기 때문이다.
  - 이것을 강한 참조(strong reference)라고 한다.

### 프로세스 종료 시 데이터 보존

- 프로세스

  - 각 앱은 프로세스로 실행된다.
  - 프로세스는 UI 관련 작업을 실행하는 하나의 스레드와 앱의 객체들을 저장하는 메모리를 포함한다.
  - 사용자가 다른 앱으로 이동하거나 안드로이드 운영체제가 메모리를 회수할 때 앱의 프로세스는 안드로이드 운영체제에 의해 소멸된다.
  - 앱의 프로세스가 소멸될 때 프로세스에 저장된 모든 객체들도 같이 소멸된다.

- 운영체제에 의한 강제 프로세스 종료

  - `실행 재개`나 `일시 중지` 상태의 액티비티를 포함하는 프로세스는 다른 프로세스보다 높은 우선순위를 갖는다.
  - 안드로이드 운영체제가 리소스를 회수할 때는 우선순위가 낮은 프로세스를 먼저 선택한다.
  - 단, 화면에 보이는 액티비티를 포함하는 프로세스는 리소스 회수가 되지 않는다.
  - 만일 화면에 보이면서 사용자와 상호 작용하는 포그라운드 프로세스의 리소스가 회수된다면 장치에 문제가 생겼음을 의미한다.
  - `중단` 상태의 액티비티는 강제 종료되기 좋은 대상이다.
  - 안드로이드 운영체제가 앱의 프로세스를 소멸시키면 메모리에 있는 앱의 모든 액티비티와 ViewModel 등 모든 객체가 제거되지만 액티비티나 ViewModel의 어떤 생명주기 콜백 함수도 호출되지 않는다.

- SIS(Saved Instance State, 저장된 인스턴스 상태)

  - SIS는 안드로이드 운영체제가 일시적으로 액티비티 외부에 저장하는 데이터이다.

  - `Activity.onSaveInstanceState(Bundle)`을 오버라이드해 SIS에 데이터를 추가할 수 있다.

  - 액티비티가 `중단` 상태로 바뀔 때는 언제든지 안드로이드 운영체제가 `Activity.onSaveInstanceState(Bundle)`을 호출한다.

  - ```
    onSaveInstanceState(Bundle)
    ```

    에서는 현재 액티비티의 모든 뷰가 자신들의 상태를 

    ```
    Bundle
    ```

     객체의 데이터로 저장한다.

    - `Bundle`은 문자열 키와 이 키의 값을 쌍으로 갖는 구조체다.

  - ```
    onCreate(Bundle?)
    ```

    에서는 인자로 받은 

    ```
    Bundle
    ```

     객체를 액티비티의 슈퍼 클래스에 정의된 

    ```
    onCreate(Bundle?)
    ```

    에 전달해 호출한다.

    - 그러면 슈퍼 클래스의 `onCreate(Bundle?)`에서는 인자로 받은 `Bundle` 객체에 저장된 뷰들의 상태 데이터를 사용해서 액티비티의 뷰 계층을 다시 생성한다.

- 액티비티 레코드(activitiy record)

  - `onSaveInstanceState(Bundle)`이 호출될 때 데이터가 저장된 `Bundle` 객체는 안드로이드 운영체제에 의해 액티비티의 `액티비티 레코드`로 저장된다.
  - 액티비티 인스턴스가 존재하지 않더라도 액티비티 레코드 객체는 안드로이드 운영체제에 살아있다.
  - 소멸 시점
    - 액티비티가 종료되었을 때
    - 장치가 다시 부팅될 때

### ViewModel vs SIS

- SIS만으로도 데이터 보존이 됨에도 불구하고 ViewModel을 사용하는 이유
  - 내부 데이터베이스나 인터넷으로부터 동적인 데이터를 가져오는 작업은 비동기적이면서 느릴 수 있고, 장치의 배터리나 네트워크 리소스를 많이 사용한다.
  - 또한, 이런 작업을 액티비티 생명주기와 결속해서 처리할 경우 오류도 많이 생길 수 있다.
  - ViewModel은 동적 데이터 처리에 효과적이다.
    - ViewModel은 장치의 구성 변경이 생겨도 다운로드 작업을 계속할 수 있게 해준다.
    - 사용자가 액티비티를 끝내면 자동으로 클린업 된다.
    - 하지만 프로세스가 종료되면 ViewModel의 데이터도 프로세스와 함께 메모리에서 완전히 제거된다.
- SIS가 주목받게 된 이유
  - SIS는 프로세스가 종료되더라도 데이터가 보존된다.
  - 그러나 SIS는 직렬화되어(serialized) 디스크에 저장되기 때문에 크거나 복잡한 객체를 저장하는 것은 좋지 않다.
- ViewModel 업데이트
  - `lifecycle-viewmodel-savedstate` 라이브러리가 새로 배포되면서 프로세스가 종료될 때 ViewModel이 자신의 상태 데이터를 보존할 수 있게 되었다.
  - 프로세스가 종료된 후 액티비티 인스턴스가 다시 생성될 때는 SIS 데이터를 사용해서 ViewModel을 설정할 수 있다.
  - 이렇게 하면 ViewModel과 액티비티가 절대 소멸되지 않는 것처럼 처리할 수 있다.

<aside> 💡 UI 상태를 다시 생성하기 위해 필요한 소량의 정보를 저장할 때는 SIS를 사용하고,
 많은 데이터에 빠르고 쉽게 접근하고자 메모리에 캐싱할 때는 ViewModel을 사용한다.</aside>

- 장치 구성이 변경된 경우

  - 이 경우에 SIS 데이터를 사용해서 ViewModel을 변경하면 ViewModel이 메모리에 남아있기 때문에 앱에서 불필요한 작업을 하게 된다.

  - 또한, ViewModel의 변경 작업으로 사용자가 기다리게 되거나 쓸데없이 배터리 등의 리소스를 사용하게 된다.

  - 그러므로 ViewModel의 데이터를 변경하기 위해 더 많은 작업이 필요할 때는 ViewModel의 데이터 갱신이 필요한지 먼저 검사한 후에 데이터를 가져오는 작업을 수행하고 변경하는 것이 좋다.

    ```kotlin
    class viewModel() : ViewModel() {
    		fun setCurrentIndex(index: Int) {
    				if (index != currentIndex) {
    						currentIndex = index
    						// 현재의 문제를 데이터베이스에서 로드한다.
    				}
    		}
    }
    ```

- 장기간 저장하는 데이터의 경우

  - 이 경우에는 ViewModel이나 SIS 모두 해결책이 아니다.
  - 따라서 액티비티 상태와 무관하게 앱이 장치에 설치되어 있는 동안 계속 남아있어야 할 데이터를 저장해야 한다면 다른 영구 저장소를 사용해야 한다.
  - 대표적인 로컬 영구 저장소 두 가지는 공유 프리퍼런스(shared preference)와 로컬 데이터베이스이다.
    - 공유 프리퍼런스는 매우 작고 간단한 데이터에 좋으며
    - 로컬 데이터베이스는 더 크고 복잡한 데이터에 적합하다.
  - 원격 서버에 데이터를 저장할 수도 있다.
  - 그러나 메모리에 비해 데이터베이스나 원격 서버로부터 데이터를 가져오는 작업은 상대적으로 느리므로 UI에 보여줄 필요가 있는 데이터를 로드하고 UI를 보여주는 동안에는 ViewModel을 사용해서 메모리에 유지하는 것이 좋다.